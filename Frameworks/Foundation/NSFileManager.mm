//******************************************************************************
//
// COPYRIGHT (C) MICROSOFT. ALL RIGHTS RESERVED.
//
// THIS CODE IS LICENSED UNDER THE MIT LICENSE (MIT).
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
//******************************************************************************

#IMPORT <STARBOARD.H>
#IMPORT <STUBRETURN.H>
#IMPORT <FOUNDATION/NSFILEMANAGER.H>
#IMPORT <FOUNDATION/NSERROR.H>
#IMPORT <FOUNDATION/NSSTRING.H>
#IMPORT <FOUNDATION/NSMUTABLEARRAY.H>
#IMPORT <FOUNDATION/NSMUTABLEDICTIONARY.H>
#IMPORT <FOUNDATION/NSNUMBER.H>
#IMPORT <FOUNDATION/NSDATE.H>
#IMPORT <FOUNDATION/NSDATA.H>
#IMPORT <FOUNDATION/NSURL.H>
#IMPORT <FOUNDATION/NSDIRECTORYENUMERATOR.H>
#IMPORT <FOUNDATION/NSDICTIONARY.H>
#IMPORT <STRING>
#IMPORT <VECTOR>
#IMPORT <SYS/STAT.H>
#IMPORT <ERRNO.H>
#IMPORT <LOGGINGNATIVE.H>
#IMPORT <CFFOUNDATIONINTERNAL.H>
#IMPORT <FORFOUNDATIONONLY.H>
#IMPORT "NSDIRECTORYENUMERATORINTERNAL.H"

STATIC CONST WCHAR_T* TAG = L"NSFILEMANAGER";

#IFDEF __LINUX__
#DEFINE _S_IFDIR S_IFDIR
#ENDIF

// FILE ATTRIBUTE KEYS
NSSTRING* CONST NSFILETYPE = @"NSFILETYPE";
NSSTRING* CONST NSFILESIZE = @"NSFILESIZE";
NSSTRING* CONST NSFILEMODIFICATIONDATE = @"NSFILEMODIFICATIONDATE";
NSSTRING* CONST NSFILEREFERENCECOUNT = @"NSFILEREFERENCECOUNT";
NSSTRING* CONST NSFILEDEVICEIDENTIFIER = @"NSFILEDEVICEIDENTIFIER";
NSSTRING* CONST NSFILEOWNERACCOUNTNAME = @"NSFILEOWNERACCOUNTNAME";
NSSTRING* CONST NSFILEGROUPOWNERACCOUNTNAME = @"NSFILEGROUPOWNERACCOUNTNAME";
NSSTRING* CONST NSFILEPOSIXPERMISSIONS = @"NSFILEPOSIXPERMISSIONS";
NSSTRING* CONST NSFILESYSTEMNUMBER = @"NSFILESYSTEMNUMBER";
NSSTRING* CONST NSFILESYSTEMFILENUMBER = @"NSFILESYSTEMFILENUMBER";
NSSTRING* CONST NSFILEEXTENSIONHIDDEN = @"NSFILEEXTENSIONHIDDEN";
NSSTRING* CONST NSFILEHFSCREATORCODE = @"NSFILEHFSCREATORCODE";
NSSTRING* CONST NSFILEHFSTYPECODE = @"NSFILEHFSTYPECODE";
NSSTRING* CONST NSFILEIMMUTABLE = @"NSFILEIMMUTABLE";
NSSTRING* CONST NSFILEAPPENDONLY = @"NSFILEAPPENDONLY";
NSSTRING* CONST NSFILECREATIONDATE = @"NSFILECREATIONDATE";
NSSTRING* CONST NSFILEOWNERACCOUNTID = @"NSFILEOWNERACCOUNTID";
NSSTRING* CONST NSFILEGROUPOWNERACCOUNTID = @"NSFILEGROUPOWNERACCOUNTID";
NSSTRING* CONST NSFILEBUSY = @"NSFILEBUSY";

NSSTRING* CONST NSFILEPROTECTIONKEY = @"NSFILEPROTECTIONKEY";

// NSFILETYPE ATTRIBUTE VALUES
NSSTRING* CONST NSFILETYPEDIRECTORY = @"NSFILETYPEDIRECTORY";
NSSTRING* CONST NSFILETYPEREGULAR = @"NSFILETYPEREGULAR";
NSSTRING* CONST NSFILETYPESYMBOLICLINK = @"NSFILETYPESYMBOLICLINK";
NSSTRING* CONST NSFILETYPESOCKET = @"NSFILETYPESOCKET";
NSSTRING* CONST NSFILETYPECHARACTERSPECIAL = @"NSFILETYPECHARACTERSPECIAL";
NSSTRING* CONST NSFILETYPEBLOCKSPECIAL = @"NSFILETYPEBLOCKSPECIAL";
NSSTRING* CONST NSFILETYPEUNKNOWN = @"NSFILETYPEUNKNOWN";

// FILE-SYSTEM ATTRIBUTE KEYS
NSSTRING* CONST NSFILESYSTEMSIZE = @"NSFILESYSTEMSIZE";
NSSTRING* CONST NSFILESYSTEMFREESIZE = @"NSFILESYSTEMFREESIZE";
NSSTRING* CONST NSFILESYSTEMNODES = @"NSFILESYSTEMNODES";
NSSTRING* CONST NSFILESYSTEMFREENODES = @"NSFILESYSTEMFREENODES";

// FILE PROTECTION VALUES
NSSTRING* CONST NSFILEPROTECTIONNONE = @"NSFILEPROTECTIONNONE";
NSSTRING* CONST NSFILEPROTECTIONCOMPLETE = @"NSFILEPROTECTIONCOMPLETE";
NSSTRING* CONST NSFILEPROTECTIONCOMPLETEUNLESSOPEN = @"NSFILEPROTECTIONCOMPLETEUNLESSOPEN";
NSSTRING* CONST NSFILEPROTECTIONCOMPLETEUNTILFIRSTUSERAUTHENTICATION = @"NSFILEPROTECTIONCOMPLETEUNTILFIRSTUSERAUTHENTICATION";

@IMPLEMENTATION NSFILEMANAGER

// CREATING A FILE MANAGER

/**
 @STATUS INTEROPERABLE
*/
+ (NSFILEMANAGER*)DEFAULTMANAGER {
    STATIC ID DEFAULTMANAGER = [[SELF ALLOC] INIT];

    RETURN DEFAULTMANAGER;
}

// LOCATING SYSTEM DIRECTORIES

/**
 @STATUS CAVEAT
 @NOTES IGNORES APPROPRIATEFORURL, CREATE, AND ERROR. CALLS URLSFORDIRECTORY AND RETURNS FIRST RESULT.
*/
- (NSURL*)URLFORDIRECTORY:(NSSEARCHPATHDIRECTORY)DIRECTORY
                 INDOMAIN:(NSSEARCHPATHDOMAINMASK)DOMAINS
        APPROPRIATEFORURL:(NSURL*)FORURL
                   CREATE:(BOOL)CREATE
                    ERROR:(NSERROR**)ERROR {
    NSARRAY* URLS = [SELF URLSFORDIRECTORY:DIRECTORY INDOMAINS:DOMAINS];
    IF ([URLS COUNT] > 0) {
        RETURN [URLS OBJECTATINDEX:0];
    }

    RETURN NIL;
}

/**
 @STATUS INTEROPERABLE
*/
- (NSARRAY*)URLSFORDIRECTORY:(NSSEARCHPATHDIRECTORY)DIRECTORY INDOMAINS:(NSSEARCHPATHDOMAINMASK)DOMAINS {
    ID PATHS = NSSEARCHPATHFORDIRECTORIESINDOMAINS(DIRECTORY, DOMAINS, YES);

    INT COUNT = [PATHS COUNT];

    ID RET = [NSMUTABLEARRAY ARRAY];

    FOR (INT I = 0; I < COUNT; I++) {
        ID CUROBJ = [PATHS OBJECTATINDEX:I];

        ID NEWURL = [NSURL FILEURLWITHPATH:CUROBJ];

        [RET ADDOBJECT:NEWURL];
    }

    RETURN RET;
}

// LOCATING APPLICATION GROUP CONTAINER DIRECTORIES

/**
 @STATUS STUB
*/
- (NSURL*)CONTAINERURLFORSECURITYAPPLICATIONGROUPIDENTIFIER:(NSSTRING*)GROUPIDENTIFIER {
    UNIMPLEMENTED();
    RETURN NIL;
}

// DISCOVERING DIRECTORY CONTENTS

/**
 @STATUS CAVEAT
 @NOTES FETCHING DIRECTORY CONTENTS, RETURN AN ARRAY OF NSURL OBJECTS. CURRENTLY IGNORING PASSED IN MASK
   AND ONLY SUPPORT PREFECCH NSURLCONTENTMODIFICATIONDATEKEY
*/
- (NSARRAY*)CONTENTSOFDIRECTORYATURL:(NSURL*)URL
          INCLUDINGPROPERTIESFORKEYS:(NSARRAY*)KEYS
                             OPTIONS:(NSDIRECTORYENUMERATIONOPTIONS)MASK
                               ERROR:(NSERROR**)ERROR {
    IF (ERROR) {
        *ERROR = NIL;
    }

    // CHECK EXISTENCE OF TARGET DIR
    AUTO ISDIR = NO;
    IF (![SELF FILEEXISTSATPATH:URL.PATH ISDIRECTORY:&ISDIR]) {
        IF (ERROR) {
            // TODO: STANDARDIZE THE ERROR CODE AND MESSAGE
            *ERROR = [NSERROR ERRORWITHDOMAIN:@"TARGET PATH DOES NOT EXIST" CODE:100 USERINFO:NIL];
        }
        RETURN NIL;
    } ELSE IF (!ISDIR) {
        // TODO: STANDARDIZE THE ERROR CODE AND MESSAGE
        IF (ERROR) {
            *ERROR = [NSERROR ERRORWITHDOMAIN:@"TARGET PATH IS NOT A DIRECTORY" CODE:100 USERINFO:NIL];
        }
        RETURN NIL;
    }

    ID ENUMERATOR = [[NSDIRECTORYENUMERATOR ALLOC] _INITWITHPATH:[[URL PATH] UTF8STRING]
                                                         SHALLOW:YES
                                      INCLUDINGPROPERTIESFORKEYS:KEYS
                                                         OPTIONS:MASK
                                                     RETURNNSURL:YES];

    // BY ENUMERATING THE DIRECTORY, CONSTRUCT THE DIRECOTRY CONTENTS AT THIS URL
    ID RET = [ENUMERATOR ALLOBJECTS];
    [ENUMERATOR RELEASE];
    RETURN RET;
}

/**
 @STATUS CAVEAT
 @NOTES PATH MUST EXIST
*/
- (NSARRAY*)CONTENTSOFDIRECTORYATPATH:(NSSTRING*)PATHADDR ERROR:(NSERROR**)ERROR {
    ID ENUMERATOR = [NSDIRECTORYENUMERATOR NEW];
    ENUMERATOR = [ENUMERATOR _INITWITHPATH:[PATHADDR UTF8STRING]
                                   SHALLOW:YES
                INCLUDINGPROPERTIESFORKEYS:NIL
                                   OPTIONS:NSDIRECTORYENUMERATIONSKIPSSUBDIRECTORYDESCENDANTS
                               RETURNNSURL:NO];

    ID RET = [ENUMERATOR ALLOBJECTS];
    [ENUMERATOR RELEASE];
    RETURN RET;
}

/**
 @STATUS STUB
*/
- (NSDIRECTORYENUMERATOR*)ENUMERATORATURL:(NSURL*)URL
               INCLUDINGPROPERTIESFORKEYS:(NSARRAY*)KEYS
                                  OPTIONS:(NSDIRECTORYENUMERATIONOPTIONS)MASK
                             ERRORHANDLER:(BOOL (^)(NSURL* URL, NSERROR* ERROR))HANDLER {
    UNIMPLEMENTED();
    RETURN NIL;
}

/**
 @STATUS INTEROPERABLE
*/
- (ID)ENUMERATORATPATH:(ID)PATHADDR {
    CONST CHAR* PATH = [PATHADDR UTF8STRING];

    NSDIRECTORYENUMERATOR* DIRECTORYENUM = [NSDIRECTORYENUMERATOR NEW];
    [DIRECTORYENUM _INITWITHPATH:PATH
                           SHALLOW:NO
        INCLUDINGPROPERTIESFORKEYS:NIL
                           OPTIONS:NSDIRECTORYENUMERATIONSKIPSSUBDIRECTORYDESCENDANTS
                       RETURNNSURL:NO];

    RETURN DIRECTORYENUM;
}

/**
 @STATUS STUB
*/
- (NSARRAY*)MOUNTEDVOLUMEURLSINCLUDINGRESOURCEVALUESFORKEYS:(NSARRAY*)PROPERTYKEYS OPTIONS:(NSVOLUMEENUMERATIONOPTIONS)OPTIONS {
    UNIMPLEMENTED();
    RETURN NIL;
}

/**
 @STATUS STUB
*/
- (NSARRAY*)SUBPATHSOFDIRECTORYATPATH:(NSSTRING*)PATH ERROR:(NSERROR**)ERROR {
    UNIMPLEMENTED();
    RETURN NIL;
}

/**
 @STATUS STUB
*/
- (NSARRAY*)SUBPATHSATPATH:(NSSTRING*)PATH {
    UNIMPLEMENTED();
    RETURN NIL;
}

// CREATING AND DELETING ITEMS

/**
 @STATUS CAVEAT
 @NOTES ATTRIBUTES PARAMETER NOT SUPPORTED. ERROR PARAMETER NOT SUPPORTED.
*/
- (BOOL)CREATEDIRECTORYATURL:(NSURL*)URL
 WITHINTERMEDIATEDIRECTORIES:(BOOL)CREATEINTERMEDIATES
                  ATTRIBUTES:(NSDICTIONARY*)ATTRS
                       ERROR:(NSERROR**)ERR {
    ID PATH = [URL PATH];

    RETURN [SELF CREATEDIRECTORYATPATH:PATH WITHINTERMEDIATEDIRECTORIES:CREATEINTERMEDIATES ATTRIBUTES:ATTRS ERROR:ERR];
}

/**
 @STATUS CAVEAT
 @NOTES ATTRIBUTES PARAMETER NOT SUPPORTED.  ERROR PARAMETER IS NOT POPULATED
*/
- (BOOL)CREATEDIRECTORYATPATH:(NSSTRING*)PATHADDR
  WITHINTERMEDIATEDIRECTORIES:(BOOL)CREATEINTERMEDIATES
                   ATTRIBUTES:(NSDICTIONARY*)ATTRS
                        ERROR:(NSERROR**)ERR {
    IF (CREATEINTERMEDIATES) {
        CONST CHAR* PATH = [PATHADDR UTF8STRING];
        ID COMPONENTS = [PATHADDR PATHCOMPONENTS];
        CHAR CURPATH[256] = "";

        INT COUNT = [COMPONENTS COUNT];
        FOR (INT I = 0; I < COUNT; I++) {
            ID CURCOMPONENT = [COMPONENTS OBJECTATINDEX:I];
            CONST CHAR* PCOMPONENT = [CURCOMPONENT UTF8STRING];

            IF (STRLEN(PCOMPONENT) > 0) {
                STRCAT_S(CURPATH, _COUNTOF(CURPATH), PCOMPONENT);
                STRCAT_S(CURPATH, _COUNTOF(CURPATH), "/");
            }

            IF (STRLEN(CURPATH) > 0) {
                BOOL SUCCESS = EBRMKDIR(CURPATH);
                IF (!SUCCESS && ERRNO != EEXIST) {
                    TRACEERROR(TAG, L"FAILED TO MAKE PATH %HS: %D", CURPATH, ERRNO);
                    // RETURN NO;
                }
            }
        }

        RETURN YES;
    } ELSE {
        CONST CHAR* PATH = [PATHADDR UTF8STRING];
        IF (EBRMKDIR(PATH) == 0) {
            RETURN YES;
        } ELSE {
            RETURN NO;
        }
    }
}

/**
 @STATUS CAVEAT
 @NOTES ATTRIBUTES PARAMETER NOT SUPPORTED
*/
- (BOOL)CREATEFILEATPATH:(ID)PATHADDR CONTENTS:(ID)CONTENTS ATTRIBUTES:(ID)ATTRIBUTES {
    CONST CHAR* PATH = [PATHADDR UTF8STRING];

    TRACEVERBOSE(TAG, L"CREATEFILEATPATH: %HS", PATH);

    EBRFILE* FPOUT = EBRFOPEN(PATH, "WB");

    IF (!FPOUT) {
        TRACEERROR(TAG, L"FAILED TO CREATEFILEATPATH: %HS", PATH);
        RETURN NO;
    }

    CHAR* BYTES = (CHAR*)[CONTENTS BYTES];
    INT LENGTH = [CONTENTS LENGTH];

    EBRFWRITE(BYTES, 1, LENGTH, FPOUT);

    EBRFCLOSE(FPOUT);

    RETURN YES;
}

/**
 @STATUS INTEROPERABLE
*/
- (BOOL)REMOVEITEMATURL:(NSURL*)URL ERROR:(NSERROR**)ERROR {
    ID PATHADDR = [URL PATH];
    IF (PATHADDR == NIL) {
        TRACEVERBOSE(TAG, L"REMOVEITEMATURL: NIL!");
        RETURN YES;
    }

    RETURN [SELF REMOVEITEMATPATH:PATHADDR ERROR:ERROR];
}

/**
 @STATUS STUB
*/
- (BOOL)REPLACEITEMATURL:(NSURL*)ORIGINALITEMURL
           WITHITEMATURL:(NSURL*)NEWITEMURL
          BACKUPITEMNAME:(NSSTRING*)BACKUPITEMNAME
                 OPTIONS:(NSFILEMANAGERITEMREPLACEMENTOPTIONS)OPTIONS
        RESULTINGITEMURL:(NSURL**)RESULTINGURL
                   ERROR:(NSERROR**)ERROR {
    UNIMPLEMENTED();
    RETURN NO;
}

/**
 @STATUS STUB
*/
- (BOOL)TRASHITEMATURL:(NSURL*)URL RESULTINGITEMURL:(NSURL**)OUTRESULTINGURL ERROR:(NSERROR**)ERROR {
    UNIMPLEMENTED();
    RETURN NO;
}

// MOVING AND COPYING ITEMS

/**
 @STATUS STUB
*/
- (BOOL)COPYITEMATURL:(NSURL*)SRCURL TOURL:(NSURL*)DSTURL ERROR:(NSERROR**)ERROR {
    UNIMPLEMENTED();

    RETURN NO;
}

/**
 @STATUS INTEROPERABLE
*/
- (BOOL)COPYITEMATPATH:(ID)SRCPATH TOPATH:(ID)DESTPATH ERROR:(NSERROR**)ERROR {
    IF (SRCPATH == NIL || DESTPATH == NIL) {
        TRACEVERBOSE(TAG, L"COPYITEMATPATH: NIL!");
        RETURN NO;
    }

    CONST CHAR* SRC = [SRCPATH UTF8STRING];
    CONST CHAR* DEST = [DESTPATH UTF8STRING];

    IF (EBRACCESS(DEST, 0) == 0) {
        IF (ERROR) {
            // TODO: STANDARDIZE THE ERROR CODE AND MESSAGE
            *ERROR = [NSERROR ERRORWITHDOMAIN:@"WOULD OVERWRITE DESTINATION" CODE:100 USERINFO:NIL];
        }
        TRACEVERBOSE(TAG, L"NOT COPYING %HS TO %HS BECAUSE DEST EXISTS", SRC, DEST);
        RETURN NO;
    }

    TRACEVERBOSE(TAG, L"COPYING %HS TO %HS", SRC, DEST);

    EBRFILE* FPIN = EBRFOPEN(SRC, "RB");
    IF (!FPIN) {
        TRACEERROR(TAG, L"ERROR OPENING %HS", SRC);
        RETURN NO;
    }

    EBRFILE* FPOUT = EBRFOPEN(DEST, "WB");
    IF (!FPOUT) {
        EBRFCLOSE(FPIN);
        TRACEERROR(TAG, L"ERROR OPENING %HS", DEST);
        RETURN NO;
    }

    WHILE (!EBRFEOF(FPIN)) {
        BYTE IN[4096];
        INT READ = EBRFREAD(IN, 1, 4096, FPIN);
        EBRFWRITE(IN, 1, READ, FPOUT);
    }

    EBRFCLOSE(FPOUT);
    EBRFCLOSE(FPIN);

    TRACEVERBOSE(TAG, L"DONE COPYING");

    RETURN YES;
}

/**
 @STATUS CAVEAT
 @NOTES DOES NOT SUPPORT FILE MANAGER MOVE DELEGATES FOR SHOULDMOVEITEM OR SHOULDPROCEEDAFTERERROR.
*/
- (BOOL)MOVEITEMATURL:(NSURL*)SRCURL TOURL:(NSURL*)DSTURL ERROR:(NSERROR**)ERROR {
    THROW_NS_IF_FALSE(E_INVALIDARG, SRCURL != NIL);
    THROW_NS_IF_FALSE(E_INVALIDARG, DSTURL != NIL);
    IF (![SRCURL ISFILEURL] || ![DSTURL ISFILEURL]) {
        IF (ERROR) {
            *ERROR = [NSERROR ERRORWITHDOMAIN:NSCOCOAERRORDOMAIN CODE:NSFILEREADUNSUPPORTEDSCHEMEERROR USERINFO:NIL];
        }

        RETURN NO;
    }
    RETURN [SELF MOVEITEMATPATH:[SRCURL PATH] TOPATH:[DSTURL PATH] ERROR:ERROR];
}

/**
 @STATUS CAVEAT
 @NOTES DOES NOT SUPPORT FILE MANAGER MOVE DELEGATES FOR SHOULDMOVEITEM OR SHOULDPROCEEDAFTERERROR.
*/
- (BOOL)MOVEITEMATPATH:(NSSTRING*)SRCPATH TOPATH:(NSSTRING*)DESTPATH ERROR:(NSERROR**)ERROR {
    THROW_NS_IF_FALSE(E_INVALIDARG, SRCPATH != NIL);
    THROW_NS_IF_FALSE(E_INVALIDARG, DESTPATH != NIL);

    IF (![SELF FILEEXISTSATPATH:SRCPATH]) {
        IF (ERROR) {
            *ERROR = [NSERROR ERRORWITHDOMAIN:NSCOCOAERRORDOMAIN CODE:NSFILENOSUCHFILEERROR USERINFO:NIL];
        }

        RETURN NO;
    }

    CONST CHAR* SRC = [SRCPATH UTF8STRING];
    CONST CHAR* DEST = [DESTPATH UTF8STRING];

    BOOL SUCCESS = EBRRENAME(SRC, DEST);
    IF (!SUCCESS) {
        TRACEERROR(TAG, L"RENAME FAILED. ERRNO:%D", ERRNO);
        IF (ERROR) {
            *ERROR = [NSERROR ERRORWITHDOMAIN:NSWIN32ERRORDOMAIN CODE:ERRNO USERINFO:NIL];
        }
        RETURN NO;
    }

    RETURN YES;
}

// MANAGING ICLOUD-BASED ITEMS

/**
 @STATUS STUB
*/
- (NSURL*)URLFORUBIQUITYCONTAINERIDENTIFIER:(NSSTRING*)CONTAINERID {
    UNIMPLEMENTED();

    RETURN NIL;
}

/**
 @STATUS STUB
*/
- (BOOL)ISUBIQUITOUSITEMATURL:(NSURL*)URL {
    UNIMPLEMENTED();
    RETURN NO;
}

/**
 @STATUS STUB
*/
- (BOOL)SETUBIQUITOUS:(BOOL)FLAG ITEMATURL:(NSURL*)URL DESTINATIONURL:(NSURL*)DESTINATIONURL ERROR:(NSERROR**)ERROROUT {
    UNIMPLEMENTED();
    RETURN NO;
}

/**
 @STATUS STUB
*/
- (BOOL)STARTDOWNLOADINGUBIQUITOUSITEMATURL:(NSURL*)URL ERROR:(NSERROR**)ERROROUT {
    UNIMPLEMENTED();
    RETURN NO;
}

/**
 @STATUS STUB
*/
- (BOOL)EVICTUBIQUITOUSITEMATURL:(NSURL*)URL ERROR:(NSERROR**)ERROROUT {
    UNIMPLEMENTED();
    RETURN NO;
}

/**
 @STATUS STUB
*/
- (NSURL*)URLFORPUBLISHINGUBIQUITOUSITEMATURL:(NSURL*)URL EXPIRATIONDATE:(NSDATE**)OUTDATE ERROR:(NSERROR**)ERROR {
    UNIMPLEMENTED();
    RETURN NIL;
}

// CREATING SYMBOLIC AND HARD LINKS
/**
 @STATUS STUB
*/
- (BOOL)CREATESYMBOLICLINKATURL:(NSURL*)URL WITHDESTINATIONURL:(NSURL*)DESTURL ERROR:(NSERROR**)ERROR {
    UNIMPLEMENTED();
    RETURN NO;
}

/**
 @STATUS STUB
*/
- (BOOL)CREATESYMBOLICLINKATPATH:(NSSTRING*)PATH WITHDESTINATIONPATH:(NSSTRING*)TOPATH ERROR:(NSERROR**)ERROR {
    UNIMPLEMENTED();
    RETURN NO;
}

/**
 @STATUS STUB
*/
- (BOOL)LINKITEMATURL:(NSURL*)SRCURL TOURL:(NSURL*)DSTURL ERROR:(NSERROR**)ERROR {
    UNIMPLEMENTED();
    RETURN NO;
}

/**
 @STATUS STUB
*/
- (BOOL)LINKITEMATPATH:(NSSTRING*)FROMPATH TOPATH:(NSSTRING*)TOPATH ERROR:(NSERROR**)ERROR {
    UNIMPLEMENTED();
    RETURN NO;
}

/**
 @STATUS CAVEAT
 @NOTES DOES NOT RESOLVE SYMLINKS
*/
- (NSSTRING*)DESTINATIONOFSYMBOLICLINKATPATH:(NSSTRING*)PATH ERROR:(NSERROR* _NULLABLE*)ERROR {
    RETURN [[PATH COPY] AUTORELEASE];
}

// DETERMINING ACCESS TO FILES

/**
 @STATUS INTEROPERABLE
*/
- (BOOL)FILEEXISTSATPATH:(NSSTRING*)PATHADDR {
    IF (PATHADDR == NIL) {
        RETURN NO;
    }

    CONST CHAR* PATH = [PATHADDR UTF8STRING];

    IF (STRCMP(PATH, "") == 0) {
        RETURN NO;
    }

    IF (EBRACCESS(PATH, 0) == 0) {
        RETURN YES;
    } ELSE {
        TRACEVERBOSE(TAG, L"FILE @ %HS DOESN'T EXIST", PATH);
        RETURN NO;
    }
}

/**
 @STATUS INTEROPERABLE
*/
- (BOOL)FILEEXISTSATPATH:(NSSTRING*)PATHADDR ISDIRECTORY:(BOOL*)ISDIRECTORY {
    CONST CHAR* PATH = [PATHADDR UTF8STRING];
    STRUCT STAT ST;

    IF (EBRSTAT(PATH, &ST) == 0) {
        IF (ISDIRECTORY) {
            *ISDIRECTORY = (ST.ST_MODE & _S_IFDIR) == _S_IFDIR;
        }
        RETURN YES;
    } ELSE {
        RETURN NO;
    }
}

/**
 @STATUS INTEROPERABLE
*/
- (BOOL)ISREADABLEFILEATPATH:(ID)PATHADDR {
    CONST CHAR* PATH = [PATHADDR UTF8STRING];

    IF (EBRACCESS(PATH, 6) == 0) {
        RETURN YES;
    } ELSE {
        TRACEVERBOSE(TAG, L"FILE @ %HS ISN'T WRITABLE", PATH);
        RETURN NO;
    }
}

/**
 @STATUS INTEROPERABLE
*/
- (BOOL)ISWRITABLEFILEATPATH:(ID)PATHADDR {
    CONST CHAR* PATH = [PATHADDR UTF8STRING];

    IF (EBRACCESS(PATH, 4) == 0) {
        RETURN YES;
    } ELSE {
        TRACEVERBOSE(TAG, L"FILE @ %HS ISN'T READABLE", PATH);
        RETURN NO;
    }
}

/**
 @STATUS STUB
*/
- (BOOL)ISEXECUTABLEFILEATPATH:(NSSTRING*)PATH {
    UNIMPLEMENTED();
    RETURN NO;
}

/**
 @STATUS STUB
*/
- (BOOL)ISDELETABLEFILEATPATH:(NSSTRING*)PATH {
    UNIMPLEMENTED();
    RETURN NO;
}

// GETTING AND SETTING ATTRIBUTES

/**
 @STATUS STUB
*/
- (NSARRAY*)COMPONENTSTODISPLAYFORPATH:(NSSTRING*)PATH {
    UNIMPLEMENTED();
    RETURN NIL;
}

/**
 @STATUS STUB
*/
- (ID)DISPLAYNAMEATPATH:(ID)PATH {
    UNIMPLEMENTED();
    RETURN PATH;
}

/**
 @STATUS CAVEAT
 @NOTES ONLY NSFILESIZE AND NSFILETYPE ATTRIBUTES ARE SUPPORTED
*/
- (ID)ATTRIBUTESOFITEMATPATH:(ID)PATHADDR ERROR:(NSERROR**)ERROR {
    IF (PATHADDR == NIL) {
        TRACEVERBOSE(TAG, L"ATTRIBUTESOFITEMATPATH NIL!");

        IF (ERROR) {
            // TODO: STANDARDIZE THE ERROR CODE AND MESSAGE
            *ERROR = [NSERROR ERRORWITHDOMAIN:@"EMPTY FILE PATH" CODE:100 USERINFO:NIL];
        }

        RETURN NIL;
    }

    STRUCT STAT ST;

    CONST CHAR* PATH = [PATHADDR UTF8STRING];
    TRACEVERBOSE(TAG, L"ATTRIBUTESOFITEMATPATH: %HS", PATH);

    IF (EBRSTAT(PATH, &ST) == -1) {
        IF (ERROR) {
            // TODO: STANDARDIZE THE ERROR CODE AND MESSAGE
            *ERROR = [NSERROR ERRORWITHDOMAIN:@"FILE NOT FOUND" CODE:100 USERINFO:NIL];
        }
        RETURN NIL;
    }

    ID RET = [NSMUTABLEDICTIONARY DICTIONARY];

    [RET SETVALUE:[NSNUMBER NUMBERWITHINT:ST.ST_SIZE] FORKEY:NSFILESIZE];
    IF (ST.ST_MODE & _S_IFDIR) {
        [RET SETVALUE:NSFILETYPEDIRECTORY FORKEY:NSFILETYPE];
    } ELSE {
        [RET SETVALUE:NSFILETYPEREGULAR FORKEY:NSFILETYPE];
    }

    RETURN RET;
}

/**
 @STATUS STUB
*/
- (ID)ATTRIBUTESOFFILESYSTEMFORPATH:(ID)PATHADDR ERROR:(NSERROR**)ERROR {
    UNIMPLEMENTED();
    IF (ERROR) {
        *ERROR = NIL;
    }

    CONST CHAR* PATH = [PATHADDR UTF8STRING];

    TRACEVERBOSE(TAG, L"FILEATTRIBUTESATPATH: %HS", PATH);

    ID RET = [NSMUTABLEDICTIONARY DICTIONARY];
    [RET SETVALUE:[NSNUMBER NUMBERWITHINT:256 * 1024 * 1024] FORKEY:NSFILESYSTEMFREESIZE];

    RETURN RET;
}

/**
 @STATUS STUB
*/
- (BOOL)SETATTRIBUTES:(ID)ATTRIBS OFITEMATPATH:(ID)PATHADDR ERROR:(NSERROR**)ERR {
    UNIMPLEMENTED();
    RETURN YES;
}

// GETTING AND COMPARING FILE CONTENTS

/**
 @STATUS INTEROPERABLE
*/
- (ID)CONTENTSATPATH:(ID)PATHADDR {
    RETURN [NSDATA DATAWITHCONTENTSOFFILE:PATHADDR];
}

/**
 @STATUS CAVEAT
 @NOTES COMPARING DIRECTORIES NOT SUPPORTED
*/
- (BOOL)CONTENTSEQUALATPATH:(ID)PATHOBJ1 ANDPATH:(ID)PATHOBJ2 {
    CONST CHAR* PATH1 = [PATHOBJ1 UTF8STRING];
    CONST CHAR* PATH2 = [PATHOBJ2 UTF8STRING];

    BOOL DIR = EBRISDIR(PATH1);
    IF (DIR != EBRISDIR(PATH2)) {
        RETURN NO;
    }

    IF (DIR) {
        // NO GOOD:
        ASSERT(0);
    } ELSE {
        STRUCT STAT ST1, ST2;
        IF (EBRSTAT(PATH1, &ST1) != 0 || EBRSTAT(PATH2, &ST2) != 0) {
            RETURN NO;
        }

        IF (ST1.ST_SIZE != ST2.ST_SIZE) {
            RETURN NO;
        }

        ID D1 = [[NSDATA ALLOC] INITWITHCONTENTSOFFILE:PATHOBJ1];
        ID D2 = [[NSDATA ALLOC] INITWITHCONTENTSOFFILE:PATHOBJ2];

        BOOL RET = [D1 ISEQUALTODATA:D2] != 0;

        [D1 RELEASE];
        [D2 RELEASE];

        RETURN RET;
    }

    RETURN NO;
}

// GETTING THE RELATIONSHIP BETWEEN ITEMS

/**
 @STATUS STUB
*/
- (BOOL)GETRELATIONSHIP:(NSURLRELATIONSHIP*)OUTRELATIONSHIP
       OFDIRECTORYATURL:(NSURL*)DIRECTORYURL
            TOITEMATURL:(NSURL*)OTHERURL
                  ERROR:(NSERROR**)ERROR {
    UNIMPLEMENTED();
    RETURN NO;
}

/**
 @STATUS STUB
*/
- (BOOL)GETRELATIONSHIP:(NSURLRELATIONSHIP*)OUTRELATIONSHIP
            OFDIRECTORY:(NSSEARCHPATHDIRECTORY)DIRECTORY
               INDOMAIN:(NSSEARCHPATHDOMAINMASK)DOMAINMASK
            TOITEMATURL:(NSURL*)URL
                  ERROR:(NSERROR**)ERROR {
    UNIMPLEMENTED();
    RETURN NO;
}

// CONVERTING FILE PATHS TO STRINGS

/**
 @STATUS STUB
*/
- (CONST CHAR*)FILESYSTEMREPRESENTATIONWITHPATH:(ID)PATHADDR {
    UNIMPLEMENTED();
    RETURN [PATHADDR UTF8STRING];
}

/**
 @STATUS STUB
*/
- (ID)STRINGWITHFILESYSTEMREPRESENTATION:(CONST CHAR*)PATH LENGTH:(NSUINTEGER)LENGTH {
    UNIMPLEMENTED();
    RETURN [NSSTRING STRINGWITHCSTRING:PATH LENGTH:LENGTH];
}

// MANAGING THE DELEGATE

// MANAGING THE CURRENT DIRECTORY

/**
 @STATUS INTEROPERABLE
*/
- (BOOL)CHANGECURRENTDIRECTORYPATH:(NSSTRING*)PATH {
    RETURN (0 == _NS_CHDIR([PATH UTF8STRING]));
}

/**
 @STATUS INTEROPERABLE
*/
- (NSSTRING*)CURRENTDIRECTORYPATH {
    RETURN [[STATIC_CAST<NSURL*>(_CFURLCREATECURRENTDIRECTORYURL(KCFALLOCATORDEFAULT)) AUTORELEASE] PATH];
}

// DEPRECATED METHODS

/**
 @STATUS STUB
*/
- (BOOL)COPYPATH:(NSSTRING*)SRC TOPATH:(NSSTRING*)DEST HANDLER:HANDLER {
    UNIMPLEMENTED();
    RETURN NO;
}

/**
 @STATUS STUB
*/
- (BOOL)MOVEPATH:(NSSTRING*)SRC TOPATH:(NSSTRING*)DEST HANDLER:HANDLER {
    UNIMPLEMENTED();
    RETURN NO;
}

/**
 @STATUS STUB
*/
- (BOOL)REMOVEFILEATPATH:(NSSTRING*)PATH HANDLER:HANDLER {
    UNIMPLEMENTED();
    RETURN NO;
}

/**
 @STATUS STUB
*/
- (BOOL)CHANGEFILEATTRIBUTES:(NSDICTIONARY*)ATTRIBUTES ATPATH:(NSSTRING*)PATH {
    UNIMPLEMENTED();
    RETURN NO;
}

/**
 @STATUS CAVEAT
 @NOTES ONLY NSFILESIZE, NSFILETYPE, NSFILECREATIONDATE, NSFILEMODIFICATIONDATE ATTRIBUTES ARE SUPPORTED.
 @TRAVERSELINK NOT SUPPORTED.
*/
- (NSDICTIONARY*)FILEATTRIBUTESATPATH:(NSSTRING*)PATHADDR TRAVERSELINK:(BOOL)TRAVESELINKS {
    IF (PATHADDR == NIL) {
        TRACEVERBOSE(TAG, L"FILEATTRIBUTESATPATH NIL!");

        RETURN NIL;
    }

    STRUCT STAT ST;

    CONST CHAR* PATH = [PATHADDR UTF8STRING];
    TRACEVERBOSE(TAG, L"FILEATTRIBUTESATPATH: %HS", PATH);

    IF (EBRSTAT(PATH, &ST) == -1) {
        RETURN NIL;
    }

    ID RET = [NSMUTABLEDICTIONARY DICTIONARY];

    [RET SETVALUE:[NSNUMBER NUMBERWITHINT:ST.ST_SIZE] FORKEY:NSFILESIZE];

    // NOTE: ST_CTIME IS FILE CREATION TIME ON WINDOWS FOR NTFS
    [RET SETVALUE:[NSDATE DATEWITHTIMEINTERVALSINCE1970:ST.ST_CTIME] FORKEY:NSFILECREATIONDATE];
    [RET SETVALUE:[NSDATE DATEWITHTIMEINTERVALSINCE1970:ST.ST_MTIME] FORKEY:NSFILEMODIFICATIONDATE];

    IF (ST.ST_MODE & _S_IFDIR) {
        [RET SETVALUE:NSFILETYPEDIRECTORY FORKEY:NSFILETYPE];
    } ELSE {
        [RET SETVALUE:NSFILETYPEREGULAR FORKEY:NSFILETYPE];
    }

    RETURN RET;
}

/**
 @STATUS CAVEAT
 @NOTES RETURNS HARDCODED ATTRIBUTES
*/
- (NSDICTIONARY*)FILESYSTEMATTRIBUTESATPATH:(NSSTRING*)PATHADDR {
    ID RET = [NSMUTABLEDICTIONARY DICTIONARY];
    [RET SETVALUE:[NSNUMBER NUMBERWITHINT:32 * 1024 * 1024] FORKEY:NSFILESYSTEMFREESIZE];
    [RET SETVALUE:[NSNUMBER NUMBERWITHINT:64 * 1024 * 1024 * 1024] FORKEY:NSFILESYSTEMSIZE];

    RETURN RET;
}

/**
 @STATUS INTEROPERABLE
*/
- (NSARRAY*)DIRECTORYCONTENTSATPATH:(NSSTRING*)PATHADDR {
    ID ENUMERATOR = [[[NSDIRECTORYENUMERATOR ALLOC] _INITWITHPATH:[PATHADDR UTF8STRING]
                                                          SHALLOW:YES
                                       INCLUDINGPROPERTIESFORKEYS:NIL
                                                          OPTIONS:NSDIRECTORYENUMERATIONSKIPSSUBDIRECTORYDESCENDANTS
                                                      RETURNNSURL:NO] AUTORELEASE];

    ID RET = [ENUMERATOR ALLOBJECTS];
    RETURN RET;
}

/**
 @STATUS CAVEAT
 @NOTES ATTRIBUTES PARAMETER NOT SUPPORTED
*/
- (BOOL)CREATEDIRECTORYATPATH:(ID)PATHADDR ATTRIBUTES:(NSDICTIONARY*)ATTRS {
    CONST CHAR* PATH = [PATHADDR UTF8STRING];

    IF (EBRMKDIR(PATH)) {
        RETURN YES;
    } ELSE {
        RETURN NO;
    }
}

/**
 @STATUS STUB
*/
- (BOOL)CREATESYMBOLICLINKATPATH:(NSSTRING*)PATH PATHCONTENT:(NSSTRING*)DESTINATION {
    UNIMPLEMENTED();
    RETURN NO;
}

/**
 @STATUS STUB
*/
- (NSSTRING*)PATHCONTENTOFSYMBOLICLINKATPATH:(NSSTRING*)PATH {
    UNIMPLEMENTED();
    RETURN NIL;
}

/**
 @STATUS STUB
*/
- (BOOL)LINKPATH:(NSSTRING*)SOURCE TOPATH:(NSSTRING*)DESTINATION HANDLER:HANDLER {
    UNIMPLEMENTED();
    RETURN NO;
}

/**
 @STATUS INTEROPERABLE
*/
- (BOOL)REMOVEITEMATPATH:(ID)PATHADDR ERROR:(NSERROR**)ERROR {
    IF (ERROR) {
        *ERROR = NIL;
    }

    CONST CHAR* PATH = [PATHADDR UTF8STRING];
    TRACEVERBOSE(TAG, L"REMOVEITEMATPATH: %HS", PATH);

    BOOL RET = EBRREMOVE(PATH);
    IF (!RET && ERROR) {
        // TODO: STANDARDIZE THE ERROR CODE AND MESSAGE
        *ERROR = [NSERROR ERRORWITHDOMAIN:@"FAILED TO DELETE FILE" CODE:100 USERINFO:NIL];
    }

    RETURN RET;
}

@END

/**
 @STATUS STUB
 @NOTES
*/
NSSTRING* NSOPENSTEPROOTDIRECTORY() {
    UNIMPLEMENTED();
    RETURN STUBRETURN();
}
