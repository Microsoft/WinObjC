<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <PropertyGroup>
    <CalculatePackageVersionDependsOn>GetVersion;$(CalculatePackageVersionDependsOn)</CalculatePackageVersionDependsOn>
    <UpdateAssemblyInfo>false</UpdateAssemblyInfo>
    <WriteVersionInfoToBuildLog>false</WriteVersionInfoToBuildLog>
    <_WinObjCVersioningTargetsImported>true</_WinObjCVersioningTargetsImported>
  </PropertyGroup>

  <!--
    Common target to caluclate the version for anything that needs it.
    This target is basically an extension of what GitVersion does but the WinObjC versioning scheme
    is slightly different and GitVersion doesn't have quite all the knobs needed to get our scheme to 
    automagically be the output of the GitVersion tool / tasks.

    NOTE: this target is also used as the NUPROJ versioning target as "PackageVersion" is what is used
    when packaging the nuget.
  -->
  <PropertyGroup>
    <GetPackageVersionDependsOn>CalculatePackageVersion;$(GetPackageVersionDependsOn);</GetPackageVersionDependsOn>
  </PropertyGroup>

  <Target Name="CalculatePackageVersion" DependsOnTargets="$(CalculatePackageVersionDependsOn)" >
    <PropertyGroup>
        <PackageVersion></PackageVersion>
    </PropertyGroup>

    <PropertyGroup>
      <PackageVersion_PreReleaseFormat Condition="'$(PackageVersion_PreReleaseFormat)' == ''">{PackageVersion_PreReleaseLabel}-{PackageVersion_Timestamp}</PackageVersion_PreReleaseFormat>
    </PropertyGroup>

    <Error Condition="'$(GitVersion_BranchName)' == ''"
           Text="Cannot determine git branch. Please make sure GitVersionTask is listed as a nuget dependency for this project and that git.exe is part of the PATH environment variable." />

    <Warning Condition="'$(SolutionPath)' == ''"
           Text="Cannot determine solution build time. Package version dependencies may be inconsistent as a result. Please make sure to build using .sln file." />

    <PropertyGroup Condition="'$(PackageVersionOverride)' == ''">
      <PackageTimestamp Condition="'$(PackageTimestamp)' == '' And Exists('$(SolutionDir)$(SolutionName).timestamp')">$([System.IO.File]::GetLastWriteTime($(SolutionDir)$(SolutionName).timestamp).ToUniversalTime().ToString(yyyyMMddHHmmss))</PackageTimestamp>      
      <PackageTimestamp Condition="'$(PackageTimestamp)' == ''">$([System.DateTime]::Now.ToUniversalTime().ToString(yyyyMMddHHmmss))</PackageTimestamp>
      
      <PackageVersion_Major>$(GitVersion_Major)</PackageVersion_Major>
      <PackageVersion_Minor>$(GitVersion_Minor)</PackageVersion_Minor>
      
      <PackageVersion_Patch Condition="'$(PackageVersion_Patch)' == '' And '$(GitVersion_PreReleaseLabel)' == ''">$([System.DateTime]::Now.ToUniversalTime().ToString(yyMMdd))</PackageVersion_Patch>
      <PackageVersion_Patch Condition="'$(PackageVersion_Patch)' == '' And '$(GitVersion_PreReleaseLabel)' != ''">$(GitVersion_Patch)</PackageVersion_Patch>

      <PackageVersion_PreReleaseLabel>$(GitVersion_PreReleaseLabel)</PackageVersion_PreReleaseLabel>
      <PackageVersion_Timestamp>$(PackageTimestamp)</PackageVersion_Timestamp>

      <!-- Replace PreReleaseFormat msbuild property names with positional String.Format args.

           NOTE: If additional property replacements are needed, they must show up here. 
           An extra cool improvement would be to figure out how to delay property expansion until this point to pass the format directly.  -->
      <PackageVersion_PreReleaseFormat>$(PackageVersion_PreReleaseFormat.Replace('PackageVersion_Timestamp', '0'))</PackageVersion_PreReleaseFormat>
      <PackageVersion_PreReleaseFormat>$(PackageVersion_PreReleaseFormat.Replace('PackageVersion_PreReleaseLabel', '1'))</PackageVersion_PreReleaseFormat>

      <PackageVersion_PreRelease Condition="'$(PackageVersion_PreRelease)' == '' And '$(PackageVersion_PreReleaseLabel)' != ''">-$([System.String]::Format('$(PackageVersion_PreReleaseFormat)', $(PackageVersion_Timestamp), $(PackageVersion_PreReleaseLabel)))</PackageVersion_PreRelease>

      <PackageVersion>$(PackageVersion_Major).$(PackageVersion_Minor).$(PackageVersion_Patch)$(PackageVersion_PreRelease)</PackageVersion>
    </PropertyGroup>

    <PropertyGroup Condition="'$(PackageVersionOverride)' != ''">

      <!-- 
      Regex for package version override string in escaped .NET syntax:
      ^v?(?<MAJOR>\d+)\.(?<MINOR>\d+)\.(?<PATCH>\d+)(\-(?<LABEL&>[\dA-Za-z\-\.]+))?$
       -->
      <_PackageVersionRegex>^v?(?&lt;MAJOR&gt;\d+)\.(?&lt;MINOR&gt;\d+)\.(?&lt;PATCH&gt;\d+)(\-(?&lt;LABEL&gt;[\dA-Za-z\-\.]+))?$</_PackageVersionRegex>

      <!-- normalize version string -->
      <PackageVersionOverride Condition="$(PackageVersionOverride.StartsWith('v'))">$(PackageVersionOverride.TrimStart('v'))</PackageVersionOverride>

      <PackageVersion>$(PackageVersionOverride)</PackageVersion>

      <!-- Pull out components for other targets to use -->
      <PackageVersion_Major>$([System.Text.RegularExpressions.Regex]::Match($(PackageVersionOverride), $(_PackageVersionRegex)).Groups['MAJOR'].Value)</PackageVersion_Major>
      <PackageVersion_Minor>$([System.Text.RegularExpressions.Regex]::Match($(PackageVersionOverride), $(_PackageVersionRegex)).Groups['MINOR'].Value)</PackageVersion_Minor>
      <PackageVersion_Patch>$([System.Text.RegularExpressions.Regex]::Match($(PackageVersionOverride), $(_PackageVersionRegex)).Groups['PATCH'].Value)</PackageVersion_Patch>
      <PackageVersion_PreReleaseLabel>$([System.Text.RegularExpressions.Regex]::Match($(PackageVersionOverride), $(_PackageVersionRegex)).Groups['LABEL'].Value)</PackageVersion_PreReleaseLabel>
    </PropertyGroup>

    <PropertyGroup Condition="$([System.UInt64]::Parse($(PackageVersion_Patch))) &gt; $([MSBuild]::Subtract($([System.UInt16]::MaxValue), '1'))">
      <PackageAssemblyVersion_Build>$(PackageVersion_Patch.Substring(0,4))</PackageAssemblyVersion_Build>
      <PackageAssemblyVersion_Revision>$(PackageVersion_Patch.Substring(4))</PackageAssemblyVersion_Revision>
    </PropertyGroup>

    <PropertyGroup>
      <PackageAssemblyVersion_Build Condition="'$(PackageAssemblyVersion_Build)' == ''">$(PackageVersion_Patch)</PackageAssemblyVersion_Build>
      <PackageAssemblyVersion_Revision Condition="'$(PackageAssemblyVersion_Revision)' == ''">0</PackageAssemblyVersion_Revision>

      <PackageAssemblyVersion>$(PackageVersion_Major).$(PackageVersion_Minor).$(PackageAssemblyVersion_Build).$(PackageAssemblyVersion_Revision)</PackageAssemblyVersion>
      <PackageAssemblyVersionTrimmed>$([System.UInt64]::Parse($(PackageVersion_Major)).ToString()).$([System.UInt64]::Parse($(PackageVersion_Minor)).ToString()).$([System.UInt64]::Parse($(PackageAssemblyVersion_Build)).ToString()).$([System.UInt64]::Parse($(PackageAssemblyVersion_Revision)).ToString())</PackageAssemblyVersionTrimmed>
      <PackageAssemblyInformationalVersion>$(PackageVersion)+$(GitVersion_FullBuildMetaData)</PackageAssemblyInformationalVersion>
      <PackageAssemblyDescription>https://github.com/Microsoft/WinObjC</PackageAssemblyDescription>
      <PackageAssemblyCompany>Microsoft</PackageAssemblyCompany>
      <PackageAssemblyCopyright>Copyright (C) Microsoft. All rights reserved</PackageAssemblyCopyright>
      <PackageAssemblyProduct>Objective-C for Windows v$(PackageVersion)</PackageAssemblyProduct>
    </PropertyGroup>
  </Target>

  <!--
    VCXPROJ Versioning target

    This target will inject a common resource file (common.rc in this same directory) into the compilation of any .dll / .exe that imports
    this .targets file. Preprocessor definitions are used to keep the verioning dynamic and configurable.
  -->
  <Target Name="AddCommonRCFile" 
          BeforeTargets="BeforeResourceCompile" 
          DependsOnTargets="CalculatePackageVersion" 
          Condition="'$(ProjectExt)' == '.vcxproj' And '$(ConfigurationType)' != 'StaticLibrary'">

    <PropertyGroup>
      <PackageAssemblyVersion_Alt>$(PackageVersion_Major),$(PackageVersion_Minor),$(PackageAssemblyVersion_Build),$(PackageAssemblyVersion_Revision)</PackageAssemblyVersion_Alt>
    </PropertyGroup>

    <ItemGroup>
      <ResourceCompile Include="$(MSBuildThisFileDirectory)\common.rc">
        <PreprocessorDefinitions>%(PreprocessorDefinitions);GIT_VERSION_ALT=$(PackageAssemblyVersion_Alt);GIT_VERSION=$(PackageAssemblyVersion);TARGET_NAME=$(TargetFileName);ASSEMBLY_COMPANY=$(PackageAssemblyCompany);ASSEMBLY_COPYRIGHT=$(PackageAssemblyCopyright);ASSEMBLY_PRODUCT=$(PackageAssemblyProduct);ASSEMBLY_DESCRIPTION=$(PackageAssemblyDescription)</PreprocessorDefinitions>
        <ResourceOutputFileName>$(TargetDir)$(TargetName).res</ResourceOutputFileName>
      </ResourceCompile>
    </ItemGroup>
  </Target>


    <!--
    VSIX Versioning target

    This target will modify the VSIX manifest that is placed in the intermediate directory during the compilation of a vsix.
    By using the intermediate directory, the working directory state isn't sullied with generated / temporary data. This does
    mean though the fixup target needs to operate more "in the build" so it isn't missed by any other vsix step. This is why
    several "DependsOn" properties now also include this target.
  -->
  <PropertyGroup>
    <GetVsixDeploymentPathDependsOn>$(GetVsixDeploymentPathDependsOn);FixUpIntermediateVSIXManifest</GetVsixDeploymentPathDependsOn>
    <CopyVsixManifestFileDependsOn>$(CopyVsixManifestFileDependsOn);FixUpIntermediateVSIXManifest</CopyVsixManifestFileDependsOn>
    <GetVsixSourceItemsDependsOn>$(GetVsixSourceItemsDependsOn);FixUpIntermediateVSIXManifest</GetVsixSourceItemsDependsOn>
  </PropertyGroup>

  <Target Name="FixUpIntermediateVSIXManifest"
          BeforeTargets="CreateVsixContainer"
          DependsOnTargets="CalculatePackageVersion;DetokenizeVsixManifestFile"
          Condition="'$(CreateVsixContainer)' == 'true'">

    <XmlPoke XmlInputPath="$(IntermediateVsixManifest)"
             Namespaces="&lt;Namespace Prefix='vsix' Uri='http://schemas.microsoft.com/developer/vsx-schema/2011' /&gt;"
             Query="/vsix:PackageManifest/vsix:Metadata/vsix:Identity/@Version"
             Value="$(PackageAssemblyVersion)"/>
  </Target>


    <!--
    APPX Versioning target

    This target will modify the Appx manifest that is generated during the compilation of an app.
    The version of the app is modified as well as the display name to make it easy to identify sample app versions.
  -->

  <Target Name="FixUpAppxManifest"
          BeforeTargets="_ValidateAppxManifest"
          DependsOnTargets="_GenerateCurrentProjectAppxManifest"
          Condition="'$(AppxPackage)' == 'true' And Exists('$(FinalAppxManifestName)')">

    <!-- Take care of package version. Use Trimmed Version since appxmanifests hilariously don't like leading 0s  -->
    <XmlPoke XmlInputPath="$(FinalAppxManifestName)"
             Namespaces="&lt;Namespace Prefix='appx' Uri='http://schemas.microsoft.com/appx/manifest/foundation/windows10' /&gt;
                         &lt;Namespace Prefix='uap' Uri='http://schemas.microsoft.com/appx/manifest/uap/windows10' /&gt;"
             Query="/appx:Package/appx:Identity/@Version"
             Value="$(PackageAssemblyVersionTrimmed)"/>

    <XmlPeek XmlInputPath="$(FinalAppxManifestName)"
             Namespaces="&lt;Namespace Prefix='appx' Uri='http://schemas.microsoft.com/appx/manifest/foundation/windows10' /&gt;
                         &lt;Namespace Prefix='uap' Uri='http://schemas.microsoft.com/appx/manifest/uap/windows10' /&gt;"
             Query="/appx:Package/appx:Properties/appx:DisplayName/text()">
      <Output TaskParameter="Result" ItemName="_PeekedVersion" />
    </XmlPeek>

    <XmlPoke XmlInputPath="$(FinalAppxManifestName)"
             Namespaces="&lt;Namespace Prefix='appx' Uri='http://schemas.microsoft.com/appx/manifest/foundation/windows10' /&gt;
                         &lt;Namespace Prefix='uap' Uri='http://schemas.microsoft.com/appx/manifest/uap/windows10' /&gt;"
             Query="/appx:Package/appx:Applications/appx:Application/uap:VisualElements/@DisplayName"
             Value="@(_PeekedVersion->'%(Identity) v$(PackageAssemblyInformationalVersion)')"/>
  </Target>


  <!--
    CSPROJ Versioning target

    This target will inject an AssemblyInfo.cs file into any csproj project that gets built.
    This is a little cumbersome so an inline task to do the file management (to help avoid rebuilds)
    is used. All metadata in the AssemblyInfo is still controllable with MSBuild properties, however.
  -->
  <UsingTask  
    TaskName="WriteAssemblyInfoFile"
    TaskFactory="CodeTaskFactory"  
    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.v12.0.dll" >
    <ParameterGroup>
      <AssemblyInfoFileFullPath  ParameterType="System.String" Required="true" />
      <AssemblyVersion ParameterType="System.String" Required="true" />
      <AssemblyFileVersion ParameterType="System.String" Required="true" />
      <AssemblyInformationalVersion ParameterType="System.String" Required="true" />
      <AssemblyTitle ParameterType="System.String" Required="true" />
      <AssemblyDescription ParameterType="System.String" Required="true" />
      <AssemblyCompany ParameterType="System.String" Required="true" />
      <AssemblyCopyright ParameterType="System.String" Required="true" />
      <AssemblyProduct ParameterType="System.String" Required="true" />
    </ParameterGroup>
    <Task>
      <Reference Include="System" />
      <Reference Include="System.IO" />
      <Using Namespace="System" />
      <Using Namespace="System.IO" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[
          var tempAssemblyInfo = string.Format(@"
              //-------------------------------------------------------------
              // <auto-generated>
              //     This code was generated by MSBuild.
              // </auto-generated>
              //---------------------------------------------------------------
              using System;
              using System.Reflection;
              [assembly: AssemblyVersion(""{0}"")]
              [assembly: AssemblyFileVersion(""{1}"")]
              [assembly: AssemblyInformationalVersion(""{2}"")]
              [assembly: AssemblyTitle(""{3}"")]
              [assembly: AssemblyDescription(""{4}"")]
              [assembly: AssemblyCompany(""{5}"")]
              [assembly: AssemblyCopyright(""{6}"")]
              [assembly: AssemblyProduct(""{7}"")]",
                      AssemblyVersion,
                      AssemblyFileVersion,
                      AssemblyInformationalVersion,
                      AssemblyTitle,
                      AssemblyDescription,
                      AssemblyCompany,
                      AssemblyCopyright,
                      AssemblyProduct);
            try
            {

                if (!File.Exists(AssemblyInfoFileFullPath) || 
                    !tempAssemblyInfo.Equals(File.ReadAllText(AssemblyInfoFileFullPath).Trim()))
                {
                  File.WriteAllText(AssemblyInfoFileFullPath, tempAssemblyInfo);
                }
            }
            catch (Exception)
            {
            }
        ]]>
      </Code>
    </Task>
  </UsingTask>

  <Target Name="AddAssemblyInfo"
          BeforeTargets="CoreCompile"
          DependsOnTargets="CalculatePackageVersion"
          Condition="'$(ProjectExt)' == '.csproj'">
    <PropertyGroup>
      <TempAssemblyInfoFileFullPath>$(IntermediateOutputPath)\$(TargetName).GeneratedAssemblyInfo.g.cs</TempAssemblyInfoFileFullPath>
    </PropertyGroup>

    <WriteAssemblyInfoFile 
      AssemblyInfoFileFullPath="$(TempAssemblyInfoFileFullPath)"
      AssemblyVersion="$(PackageAssemblyVersion)"
      AssemblyFileVersion="$(PackageAssemblyVersion)"
      AssemblyInformationalVersion="$(PackageAssemblyInformationalVersion)"
      AssemblyTitle="$(TargetFileName)"
      AssemblyDescription="$(PackageAssemblyDescription)"
      AssemblyCompany="$(PackageAssemblyCompany)"
      AssemblyCopyright="$(PackageAssemblyCopyright)"
      AssemblyProduct="$(PackageAssemblyProduct)"/>

    <ItemGroup>
      <Compile Include="$(TempAssemblyInfoFileFullPath)" Condition="Exists('$(TempAssemblyInfoFileFullPath)')"/>
    </ItemGroup>
  </Target>

  <!-- Manually import this checked in NuGet instead of relying on the package itself since it is being used
       to adjust the Restore process. If it were a normal NuGet dependency, it also would need restored which means it
       couldn't adjust the restore process itself as it would already be too late. -->
  <Import Project="$(MSBuildThisFileDirectory)\gitversiontask\4.0.0-beta0011\build\GitVersionTask.targets" Condition="'$(GitVersion_Task_targets_Imported)' == ''"/>

</Project>