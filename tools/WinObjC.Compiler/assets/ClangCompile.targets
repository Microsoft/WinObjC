<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <ItemGroup>
    <PropertyPageSchema
      Include="$(MSBuildThisFileDirectory)$(MSBuildThisFileName).xml" />
    <AvailableItemName
      Include="ClangCompile">
      <Targets>_ClangCompile</Targets>
    </AvailableItemName>
  </ItemGroup>

  <UsingTask
    TaskName="Clang"
    AssemblyFile="ClangCompileTask.dll"/>

  <PropertyGroup>
    <ClangCompileDependsOn>_SelectedFiles;MakeDirsForClang;GenerateHeaderMaps;ComputeClangOptions</ClangCompileDependsOn>
    <ClangCompileBeforeTargets>ClCompile;Link;Lib;ImpLib</ClangCompileBeforeTargets>
    <ClangCompileAfterTargets></ClangCompileAfterTargets>
    <BeforeClCompileTargets>_ClangCompile;$(BeforeClCompileTargets)</BeforeClCompileTargets>
    <BuildCompileTargets>_ClangCompile;$(BuildCompileTargets)</BuildCompileTargets>
  </PropertyGroup>

  <PropertyGroup>
    <ClangCompileExtraInputs>$(MSBuildProjectFile)</ClangCompileExtraInputs>
    <CombinedHMapFilename>$([System.IO.Path]::Combine('$(ProjectDir)', '$(IntDir)', '$(MSBuildProjectName)-combined'))</CombinedHMapFilename>
    <ProjectHMapFilename>$([System.IO.Path]::Combine('$(ProjectDir)', '$(IntDir)', '$(MSBuildProjectName)-project'))</ProjectHMapFilename>
    <CombinedHMapRequired>@(ClangCompile->AnyHaveMetadataValue('HeaderMap','Combined'))</CombinedHMapRequired>
    <ProjectHMapRequired>@(ClangCompile->AnyHaveMetadataValue('HeaderMap','Project'))</ProjectHMapRequired>
    <HMapAddFrameworkEntries>@(ClangCompile->AnyHaveMetadataValue('HeaderMapAddFrameworkEntries','true'))</HMapAddFrameworkEntries>
    <DummyClangFile>$(IntDir)DummyNoCompile.mm</DummyClangFile>
  </PropertyGroup>
  
  <PropertyGroup>
    <!-- BuildLinkTargets is only defined for vcxproj. C# "Links" by calling csc with multiple files so the Compile step should be sufficient there -->
    <RemoveExtraLibsDependsOn Condition="'$(ProjectExt)' != '.vcxproj'">Compile;</RemoveExtraLibsDependsOn>
    <RemoveExtraLibsDependsOn Condition="'$(ProjectExt)' == '.vcxproj'">Link;</RemoveExtraLibsDependsOn>
  </PropertyGroup>

  <Target
    Name="RemoveExtraLibs"
    BeforeTargets="_CopyFilesMarkedCopyLocal"
    Condition="'$(ConfigurationType)' != 'Utility' And '$(ConfigurationType)' != 'StaticLibrary'"
    DependsOnTargets="$(RemoveExtraLibsDependsOn)">

    <PropertyGroup>
      <DepWalkerSearchPathFile>$(IntDir)$(ProjectName).dwp</DepWalkerSearchPathFile>
      <LibPathPattern>^,"([^"]*.\DLL)"</LibPathPattern>
    </PropertyGroup>

    <!-- 
         0. Before doing any actual dependency walking and removing of extra libs, check that the user hasn't added
         any missing/non-existent ReferenceCopyLocalPaths that are WinObjC ones. If they are winobjc ones, make sure
         that those aren't candidates to be removed as the user was explicit in the desire to copy them 
    -->
    <ItemGroup>
      <_NonExistentReferenceCopyLocalPaths Include="@(ReferenceCopyLocalPaths)" Condition="!Exists('%(ReferenceCopyLocalPaths.FullPath)')" />
      <_WinObjCReferenceCopyLocalPaths Include="@(ReferenceCopyLocalPaths)" Condition="'%(ReferenceCopyLocalPaths.IsWinObjC)' == 'true'"/>

      <!-- Filter down to only the items that are also IsWinObjC and have a matching Filename -->
      <_NonExistentReferenceCopyLocalPaths Remove="@(_NonExistentReferenceCopyLocalPaths)" Condition="'%(FileName)' == '' And '@(_WinObjCReferenceCopyLocalPaths)' != '' And '@(_NonExistentReferenceCopyLocalPaths)' != ''" />

      <!-- Non existent ReferenceCopyLocalPaths cause build errors so remove them -->
      <ReferenceCopyLocalPaths Remove="@(_NonExistentReferenceCopyLocalPaths)" />

      <!-- Fixup the original WinObjC ReferenceCopyLocalPaths to not be a candidate for removal -->
      <ReferenceCopyLocalPaths Condition="'%(FileName)' != '' And '@(ReferenceCopyLocalPaths)' != '' And '@(_NonExistentReferenceCopyLocalPaths)' != ''">
        <IsWinObjC></IsWinObjC>
      </ReferenceCopyLocalPaths>
    </ItemGroup>

    <!-- 1. Collect items that need to be walked. This includes the main target and all refernces. -->
    <ItemGroup>
      <DepWalkerInputs Include="$(TargetPath)" />

      <!-- Assume dll is next to winmd -->
      <_DepWalkerInputs Include="@(Reference -> '%(RootDir)%(Directory)%(Implementation)')" Condition="'%(Reference.Extension)' == '.winmd' And '%(Reference.Implementation)' != ''" />
      <DepWalkerInputs Include="@(_DepWalkerInputs->Distinct())" />
    </ItemGroup>

    <ItemGroup>
      <!-- Add in a command and output file metadata for each item that needs walked.  -->
      <DepWalkerInputs>
        <OutputFile>$(IntDir)%(FileName).dwo</OutputFile>
      </DepWalkerInputs>
      <DepWalkerInputs>
        <Command>"$(MSBuildThisFileDirectory)..\bin\depends.exe" /c /f:1 /d:"$(DepWalkerSearchPathFile)" /oc:"%(OutputFile)" "%(FullPath)"</Command>
      </DepWalkerInputs>
    </ItemGroup>

    <!-- 
         2. Collect dep walker search paths and write to a file. This is the closure of all WinObjC ReferenceCopyLocalPaths dlls.

         In order to distinguish between ReferenceCopyLocalPaths that the app itself or other middleware may have added and WinObjC specific ones, look for
         the IsWinObjC metadata. This is a more conservative approach to dependency walking as only the WinObjC binaries are subject to being exceluded from
         ending up in the output directory. Additionally, all "sidecar" files (like .pri files / .winmds / etc) that a dll may need are going to end up in the
         the output regardless. The assumption is that these are small enough to not care about for now.
     -->
    <ItemGroup>
      <DepWalkerSearchPaths Include="@(ReferenceCopyLocalPaths -> 'UserDir %(RootDir)%(Directory)')" Condition="'%(ReferenceCopyLocalPaths.Extension)' == '.dll' And '%(ReferenceCopyLocalPaths.IsWinObjC)' == 'true'" />
    </ItemGroup>
    
    <WriteLinesToFile
      File="$(DepWalkerSearchPathFile)"
      Encoding="ASCII"
      Overwrite="true"
      Lines="@(DepWalkerSearchPaths->Distinct())" />

    <!-- 3. Call Dependency Walker -->
    <Exec
      Condition="Exists('%(DepWalkerInputs.FullPath)')"
      IgnoreExitCode="true"
      Command="%(DepWalkerInputs.Command)" />

    <!-- 4. Read Dependency Walker output -->
    <ReadLinesFromFile File="%(DepWalkerInputs.OutputFile)">
      <Output TaskParameter="Lines" ItemName="DepWalkerOutputLines"/>
    </ReadLinesFromFile>

    <!-- 5. Extract dependencies -->
    <ItemGroup>
      <_DependenciesToInclude Include="$([System.Text.RegularExpressions.Regex]::Match('%(DepWalkerOutputLines.Identity)', $(LibPathPattern)).Groups[1].Value)"/>
    </ItemGroup>

    <!-- 6. Do a little set subtraction to figure out which items to *NOT* include since by default all items are copied. 
            This is a little more robust of a failure mode but is more complicated to calculate. -->
    <ItemGroup>
      <_ReferenceCopyLocalPathsToRemove Include="@(ReferenceCopyLocalPaths)" Condition="'%(ReferenceCopyLocalPaths.Extension)' == '.dll' And '%(ReferenceCopyLocalPaths.IsWinObjC)' == 'true'"  />
      <_ReferenceCopyLocalPathsToRemove Remove="@(_ReferenceCopyLocalPathsToRemove)" Condition="'%(FileName)' != '' And '@(_DependenciesToInclude)' != '' And '@(_ReferenceCopyLocalPathsToRemove)' != ''" />
      <ReferenceCopyLocalPaths Remove="@(_ReferenceCopyLocalPathsToRemove)" />
    </ItemGroup>
    
  </Target>

  <Target Name="ComputeStarboardCRT">
    <!-- Inject a dummy ClangCompile file to gain access to autocomplete arguments for the project.
         If the project doesn't contain any explicit ClangCompile files, this also helps with the
         computation of the StarboardCRT. -->
    <ItemGroup>
      <ClangCompile Include="$(DummyClangFile)">
        <ExcludedFromBuild>true</ExcludedFromBuild>
      </ClangCompile>
    </ItemGroup>

    <PropertyGroup>
      <!-- Choose a CRT to use -->
      <ClangCompileCRTs>@(ClangCompile->Metadata('RuntimeLibrary')->Distinct()->ClearMetadata())</ClangCompileCRTs>
      <ClangCompilePreprocessorDefinitions>@(ClangCompile->Metadata('PreprocessorDefinitions')->Distinct()->ClearMetadata())</ClangCompilePreprocessorDefinitions>
      <StarboardCRT>MultiThreadedDLL</StarboardCRT>
      <StarboardCRT Condition="$(ClangCompileCRTs.Contains('MultiThreadedDebugDLL'))">MultiThreadedDebugDLL</StarboardCRT>
      <!-- Choose configuration that corresponds to the CRT -->
      <StarboardCRTConfig>Release</StarboardCRTConfig>
      <StarboardCRTConfig Condition="'$(StarboardCRT)' == 'MultiThreadedDebugDLL'">Debug</StarboardCRTConfig>
    </PropertyGroup>
  </Target>

  <Target
    Name="_ClangCompile"
    BeforeTargets="$(ClangCompileBeforeTargets)"
    AfterTargets="$(ClangCompileAfterTargets)"
    Condition="'@(ClangCompile)' != ''"
    DependsOnTargets="$(ClangCompileDependsOn)">
    <!-- Handle building of selected files -->
    <ItemGroup Condition="'@(SelectedFiles)' != ''">
      <ClangCompile Remove="@(ClangCompile)" Condition="'%(Identity)' != '@(SelectedFiles)'" />
    </ItemGroup>

    <Message
      Condition="'@(ClangCompile)' != '' and '%(ClangCompile.MaxClangProcesses)' != '1' and '%(ClangCompile.ObjectiveCModules)' == 'true'"
      Importance="High"
      Text="Note: Setting MaxClangProcesses to 1 because Modules are enabled." />

    <ItemGroup>
      <ClangCompile>
        <MaxClangProcesses Condition="'@(ClangCompile)' != '' and '%(ClangCompile.MaxClangProcesses)' != '1' and '%(ClangCompile.ObjectiveCModules)' == 'true'">1</MaxClangProcesses>
      </ClangCompile>
    </ItemGroup>

    <Error Condition="'@(ClangCompile)' != '' and ('%(ClangCompile.MaxClangProcesses)' &lt; '-1' or '%(ClangCompile.MaxClangProcesses)' == '0')"
      Text="%(ClangCompile.MaxClangProcesses) is an invalid value for MaxClangProcesses. MaxClangProcesses must be -1, or a postive integer." />

    <!-- Call Clang, passing AdditionalOptions as the LAST argument -->
    <Clang
      Condition="'@(ClangCompile)' != '' and '%(ClangCompile.ExcludedFromBuild)' != 'true'"
      InternalSystemIncludePaths="%(ClangCompile.InternalSystemIncludePaths)"
      InternalIncludePaths="%(ClangCompile.InternalIncludePaths)"
      InternalForceIncludes="%(ClangCompile.InternalForceIncludes)"
      ExcludedSearchPathSubdirectories="%(ClangCompile.ExcludedSearchPathSubdirectories)"
      Autocomplete="$(ClangAutocomplete)"
      AutocompleteCommandLineTemplate="%(ClangCompile.AutocompleteCommandLineTemplate)"
      CommandLineTemplate="%(ClangCompile.CommandLineTemplate)"
      CommandTLogFile="%(ClangCompile.CommandTLogFile)"
      CompileAs="%(ClangCompile.CompileAs)"
      DebugInformation="%(ClangCompile.DebugInformation)"
      DependencyFile="%(ClangCompile.DependencyFile)"
      ExceptionHandling="%(ClangCompile.ExceptionHandling)"
      HeaderMapInclude="%(ClangCompile.HeaderMapInclude)"
      IncludePaths="%(ClangCompile.IncludePaths)"
      Input="@(ClangCompile)"
      LLVMDirectory="$(StarboardLLVMDirectory)"
      ObjectiveCARC="%(ClangCompile.ObjectiveCARC)"
      ObjectiveCModules="%(ClangCompile.ObjectiveCModules)"
      ObjectiveCModulesCachePath="%(ClangCompile.ObjectiveCModulesCachePath)"
      ObjectFileName="%(ClangCompile.ObjectFileName)"
      OptimizationLevel="%(ClangCompile.OptimizationLevel)"
      PrefixHeader="%(ClangCompile.PrefixHeader)"
      PreprocessorDefinitions="%(ClangCompile.PreprocessorDefinitions)"
      ProjectFile="$(MSBuildProjectFullPath)"
      RuntimeLibrary="%(ClangCompile.RuntimeLibrary)"
      SystemHeaderDeps="%(ClangCompile.SystemHeaderDeps)"
      UserIncludePaths="%(ClangCompile.UserIncludePaths)"
      ReadTLogFile="%(ClangCompile.ReadTLogFile)"
      MaxClangProcesses="%(ClangCompile.MaxClangProcesses)"
      CLanguageStandard="%(ClangCompile.CLanguageStandard)"
      CppLanguageStandard="%(ClangCompile.CppLanguageStandard)"
      AdditionalOptions="%(ClangCompile.OtherFlags) %(ClangCompile.AdditionalOptions)">
      <Output TaskParameter="Outputs" ItemName="ClangOutputs" />
    </Clang>
  </Target>

  <Target
    Name="GenerateHeaderMaps"
    DependsOnTargets="GenerateCombinedHMap;GenerateProjectHMap;WriteHeaderMaps" />

  <Target
    Name="ComputeCombinedHMap">

    <ItemGroup>
      <HeaderMapEntry Include="%(ClangCompile.RootDir)%(ClangCompile.Directory)*.h" />
      <HeaderMapEntry Include="%(ClangCompile.RootDir)%(ClangCompile.Directory)*.hh" />
      <HeaderMapEntry Include="%(ClangCompile.RootDir)%(ClangCompile.Directory)*.hpp" />
      <HeaderMapEntry Include="%(ClangCompile.RootDir)%(ClangCompile.Directory)*.pch" />
      <HeaderMapEntry Include="%(ClInclude.FullPath)" />
      <HeaderMapEntry Condition="'$(HMapAddFrameworkEntries)' == 'true'" Include="%(ClInclude.FullPath)&#x9;$(TargetName)/%(ClInclude.Filename)%(ClInclude.Extension)" />
      <HeaderMap Include="$(CombinedHMapFilename)" />
    </ItemGroup>
  </Target>

  <Target
    Name="GenerateCombinedHMap"
    DependsOnTargets="ComputeCombinedHMap"
    Condition="'$(CombinedHMapRequired)' == 'true'"
    Inputs="@(HeaderMapEntry)"
    Outputs="$(CombinedHMapFilename).txt">

    <!-- Only support ASCII paths for now -->
    <WriteLinesToFile
      File="$(CombinedHMapFilename).txt"
      Lines="@(HeaderMapEntry)"
      Overwrite="true"
      Encoding="ASCII" />

    <ItemGroup>
      <HeaderMapEntry Remove="@(HeaderMapEntry)" />
    </ItemGroup>
  </Target>

  <Target
    Name="ComputeProjectHMap">

    <ItemGroup>
      <HeaderMapEntry Include="%(ClInclude.FullPath)" />
      <HeaderMapEntry Condition="'$(HMapAddFrameworkEntries)' == 'true'" Include="%(ClInclude.FullPath)&#x9;$(TargetName)/%(ClInclude.Filename)%(ClInclude.Extension)" />
      <HeaderMap Include="$(ProjectHMapFilename)" />
    </ItemGroup>

    <ItemGroup Condition="@(HeaderMapEntry) == ''">
      <HeaderMapEntry Include="Empty" />
    </ItemGroup>
  </Target>

  <Target
    Name="GenerateProjectHMap"
    DependsOnTargets="ComputeProjectHMap"
    Condition="'$(ProjectHMapRequired)' == 'true'"
    Inputs="@(HeaderMapEntry)"
    Outputs="$(ProjectHMapFilename).txt">

    <!-- Only support ASCII paths for now -->
    <WriteLinesToFile
      File="$(ProjectHMapFilename).txt"
      Lines="@(HeaderMapEntry)"
      Overwrite="true"
      Encoding="ASCII" />

    <ItemGroup>
      <HeaderMapEntry Remove="@(HeaderMapEntry)" />
    </ItemGroup>
  </Target>

  <Target
    Name="WriteHeaderMaps"
    Condition="'@(HeaderMap)' != ''"
    Inputs="@(HeaderMap->'%(Identity).txt')"
    Outputs="@(HeaderMap->'%(Identity).hmap')">

    <Exec
      Command="&quot;$(MSBuildThisFileDirectory)..\bin\hmapmaker.exe&quot; &quot;%(HeaderMap.Identity).txt&quot; &quot;%(HeaderMap.Identity).hmap&quot;" />
  </Target>

  <!-- Create parent directories for all object files -->
  <Target Name="MakeDirsForClang" Condition="'@(ClangCompile)' != ''" DependsOnTargets="ComputeClangOptions">
    <MakeDir Directories="@(ClangCompile->Metadata('ObjectFileName')->DirectoryName()->Distinct()->ClearMetadata())" />
  </Target>
  
  <Target
    Name="ComputeClangOptions"
    DependsOnTargets="ComputeStarboardCRT">

    <!-- Figure out what to compile each file as -->
    <ItemGroup>
      <ClangCompile Condition="'%(ClangCompile.CompileAs)' == 'Default' or '%(ClangCompile.CompileAs)' == ''">
        <CompileAs Condition="'%(Extension)'=='.c'">CompileAsC</CompileAs>
        <CompileAs Condition="'%(Extension)'=='.m'">CompileAsObjC</CompileAs>
        <CompileAs Condition="'%(Extension)'=='.cpp' or '%(Extension)'=='.cc' or '%(Extension)'=='.cxx'">CompileAsCpp</CompileAs>
        <CompileAs Condition="'%(Extension)'=='.mm' or '%(Extension)'=='.mxx'">CompileAsObjCpp</CompileAs>
      </ClangCompile>
    </ItemGroup>

    <!-- Figure out language-specific flags -->
    <ItemGroup>
      <ClangCompile>
        <OtherFlags Condition="'%(ClangCompile.CompileAs)' == 'CompileAsC' or
                               '%(ClangCompile.CompileAs)' == 'CompileAsObjC'">%(ClangCompile.OtherCFlags)</OtherFlags>
        <OtherFlags Condition="'%(ClangCompile.CompileAs)' == 'CompileAsCpp' or
                               '%(ClangCompile.CompileAs)' == 'CompileAsObjCpp'">%(ClangCompile.OtherCPlusPlusFlags)</OtherFlags>

        <!-- Clear the language standard for the language we're _not_ compiling -->
        <CLanguageStandard Condition="'%(ClangCompile.CompileAs)' != 'CompileAsC' and
                                      '%(ClangCompile.CompileAs)' != 'CompileAsObjC'"></CLanguageStandard>
        <CppLanguageStandard Condition="'%(ClangCompile.CompileAs)' != 'CompileAsCpp' and
                                        '%(ClangCompile.CompileAs)' != 'CompileAsObjCpp'"></CppLanguageStandard>
      </ClangCompile>
    </ItemGroup>

    <!-- Figure out which header map to use -->
    <ItemGroup>
      <ClangCompile>
        <HeaderMapInclude Condition="'%(ClangCompile.HeaderMap)' == 'Project'">-I"$(ProjectHMapFilename).hmap"</HeaderMapInclude>
        <HeaderMapInclude Condition="'%(ClangCompile.HeaderMap)' == 'Combined'">-I"$(CombinedHMapFilename).hmap"</HeaderMapInclude>
      </ClangCompile>
    </ItemGroup>

    <!-- Add in the ClCompile additional include directories to clang. -->
    <PropertyGroup>
      <_ShouldMakeTmpClCompile Condition="'@(ClCompile)' == ''">true</_ShouldMakeTmpClCompile>
    </PropertyGroup>
    <ItemGroup>
      <ClCompile Include="_tmp" Condition="'$(_ShouldMakeTmpClCompile)' == 'true'"/>
      <ClangCompile Condition="'%(ClangCompile.Identity)' != ''">
          <IncludePaths>@(ClCompile->Metadata('AdditionalIncludeDirectories')->Distinct()->ClearMetadata());%(ClangCompile.IncludePaths);</IncludePaths>
      </ClangCompile>
      <ClCompile Remove="_tmp" Condition="'$(_ShouldMakeTmpClCompile)' == 'true'"/>
    </ItemGroup>
  </Target>

  <!-- Ensure Link/Lib/ImpLib pick up the object files -->
  <ItemDefinitionGroup>
    <ClangOutputs>
      <LinkCompiled>$(LinkCompiled)</LinkCompiled>
      <LibCompiled>$(LibCompiled)</LibCompiled>
      <ImpLibCompiled>$(ImpLibCompiled)</ImpLibCompiled>
    </ClangOutputs>
  </ItemDefinitionGroup>

  <PropertyGroup>
    <ComputeLinkInputsTargets>$(ComputeLinkInputsTargets);ComputeClangLinkInputs;</ComputeLinkInputsTargets>
    <ComputeLibInputsTargets>$(ComputeLibInputsTargets);ComputeClangLibInputs;</ComputeLibInputsTargets>
    <ComputeImpLibInputsTargets>$(ComputeImpLibInputsTargets);ComputeClangImpLibInputs;</ComputeImpLibInputsTargets>
  </PropertyGroup>


  <PropertyGroup>
    <ComputeLinkInputsTargets>$(ComputeLinkInputsTargets);AddCRTLinkInputs;</ComputeLinkInputsTargets>
  </PropertyGroup>

  <Target
    Name="AddCRTLinkInputs">

    <ItemGroup>
      <ClCompile Include="tmp" Condition="'@(ClCompile)'==''">
       <DeleteSoon>true</DeleteSoon>
      </ClCompile>
    </ItemGroup>

    <PropertyGroup>
      <ClCompileCRTs>@(ClCompile->Metadata('RuntimeLibrary')->Distinct()->ClearMetadata())</ClCompileCRTs>
    </PropertyGroup>

    <ItemGroup Condition="$(ClCompileCRTs.ToLower().Contains('multithreadeddll'))">
      <Link Include="vccorlib.lib" />
      <Link Include="msvcrt.lib" />
      <Link Condition="'$(UseWinObjCCRT)' == 'true'" Include="WinObjCRT.lib" />
      <Link Include="ucrt.lib" />
    </ItemGroup>

    <ItemGroup Condition="$(ClCompileCRTs.ToLower().Contains('multithreadeddebugdll'))">
      <Link Include="vccorlibd.lib" />
      <Link Include="msvcrtd.lib" />
      <Link Condition="'$(UseWinObjCCRT)' == 'true'" Include="WinObjCRT.lib" />
      <Link Include="ucrtd.lib" />
    </ItemGroup>

    <ItemGroup>
      <ClCompile Remove="@(ClCompile)" Condition="'%(ClCompile.DeleteSoon)'=='true'" />
    </ItemGroup>

  </Target>

  <Target Name="ComputeClangLinkInputs" DependsOnTargets="_ClangCompile">
    <ItemGroup>
      <Link Condition="'%(ClangOutputs.LinkCompiled)' == 'true'" Include="%(ClangOutputs.ObjectFileName)" />
    </ItemGroup>
  </Target>
  <Target Name="ComputeClangLibInputs" DependsOnTargets="ComputeClangOptions;_ClangCompile">
    <ItemGroup>
      <Lib Condition="'%(ClangOutputs.LibCompiled)' == 'true'" Include="%(ClangOutputs.ObjectFileName)" />
    </ItemGroup>
  </Target>
  <Target Name="ComputeClangImpLibInputs" DependsOnTargets="ComputeClangOptions;_ClangCompile">
    <ItemGroup>
      <ImpLib Condition="'%(ClangOutputs.ImpLibCompiled)' == 'true'" Include="%(ClangOutputs.ObjectFileName)" />
    </ItemGroup>
  </Target>

  <!-- Clean generated files -->
  <PropertyGroup>
    <CleanDependsOn>$(CleanDependsOn);CleanClang;</CleanDependsOn>
  </PropertyGroup>

  <Target Name="CleanClang" Condition="'@(ClangCompile)' != ''" DependsOnTargets="ComputeClangOptions">
    <!-- Delete header maps -->
    <Delete Files="$(CombinedHMapFilename).txt;$(CombinedHMapFilename).hmap;$(ProjectHMapFilename).txt;$(ProjectHMapFilename).hmap" />
    <RemoveDir Directories="@(ClangCompile->Metadata('ObjectiveCModulesCachePath')->Distinct()->ClearMetadata())" />
  </Target>

  <PropertyGroup>
    <UseWinObjCCRT Condition="'$(UseWinObjCCRT)' == ''">true</UseWinObjCCRT>
  </PropertyGroup>

  <ItemDefinitionGroup>
    <Link Condition="'$(UseWinObjCCRT)' == 'true'">
      <AdditionalOptions>/DISALLOWLIB:libucrt.lib /DISALLOWLIB:libucrtd.lib /nodefaultlib:ucrt /nodefaultlib:ucrtd /nodefaultlib:vccorlib /nodefaultlib:msvcrt /nodefaultlib:vccorlibd /nodefaultlib:msvcrtd /defaultlib:winobjcrt %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>

</Project>
